"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-slippy-map-globe";
exports.ids = ["vendor-chunks/three-slippy-map-globe"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThreeSlippyMapGlobe)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-octree */ \"(ssr)/./node_modules/d3-octree/src/octree.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/linear.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/projection/mercator.js\");\n\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (String )(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar _materialDispose = function materialDispose(material) {\n  if (material instanceof Array) {\n    material.forEach(_materialDispose);\n  } else {\n    if (material.map) {\n      material.map.dispose();\n    }\n    material.dispose();\n  }\n};\nvar _deallocate = function deallocate(obj) {\n  if (obj.geometry) {\n    obj.geometry.dispose();\n  }\n  if (obj.material) {\n    _materialDispose(obj.material);\n  }\n  if (obj.texture) {\n    obj.texture.dispose();\n  }\n  if (obj.children) {\n    obj.children.forEach(_deallocate);\n  }\n};\nvar emptyObject = function emptyObject(obj) {\n  if (obj && obj.children) while (obj.children.length) {\n    var childObj = obj.children[0];\n    obj.remove(childObj);\n    _deallocate(childObj);\n  }\n};\n\nfunction polar2Cartesian(lat, lng, r) {\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return {\n    x: r * Math.sin(phi) * Math.cos(theta),\n    y: r * Math.cos(phi),\n    z: r * Math.sin(phi) * Math.sin(theta)\n  };\n}\nfunction cartesian2Polar(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    z = _ref.z;\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var phi = Math.acos(y / r);\n  var theta = Math.atan2(z, x);\n  return {\n    lat: 90 - phi * 180 / Math.PI,\n    lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),\n    // keep within [-180, 180] boundaries\n    r: r\n  };\n}\nfunction deg2Rad(deg) {\n  return deg * Math.PI / 180;\n}\n\nvar yMercatorScale = function yMercatorScale(y) {\n  return 1 - ((0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw)(0, (0.5 - y) * Math.PI)[1] / Math.PI + 1) / 2;\n};\nvar yMercatorScaleClamped = function yMercatorScaleClamped(y) {\n  return Math.max(0, Math.min(1, yMercatorScale(y)));\n};\nvar yMercatorScaleInvert = function yMercatorScaleInvert(y) {\n  return 0.5 - d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw.invert(0, (2 * (1 - y) - 1) * Math.PI)[1] / Math.PI;\n};\nvar convertMercatorUV = function convertMercatorUV(uvs) {\n  var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var y1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var offsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([1, 0]).range([y0, y1]).clamp(true);\n  var revOffsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([yMercatorScaleClamped(y0), yMercatorScaleClamped(y1)]).range([1, 0]).clamp(true);\n  var scale = function scale(v) {\n    return revOffsetScale(yMercatorScaleClamped(offsetScale(v)));\n  };\n  var arr = uvs.array;\n  for (var i = 0, len = arr.length; i < len; i += 2) {\n    arr[i + 1] = scale(arr[i + 1]);\n  }\n  uvs.needsUpdate = true;\n};\n\nvar findTileXY = function findTileXY(level, isMercator, lng, lat) {\n  var gridSize = Math.pow(2, level);\n  var x = Math.max(0, Math.min(gridSize - 1, Math.floor((lng + 180) * gridSize / 360)));\n  var relY = (90 - lat) / 180;\n  isMercator && (relY = Math.max(0, Math.min(1, yMercatorScale(relY))));\n  var y = Math.floor(relY * gridSize);\n  return [x, y];\n};\nvar genTilesCoords = function genTilesCoords(level, isMercator) {\n  var x0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var y0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var _x1 = arguments.length > 4 ? arguments[4] : undefined;\n  var _y1 = arguments.length > 5 ? arguments[5] : undefined;\n  var tiles = [];\n  var gridSize = Math.pow(2, level);\n  var tileLngLen = 360 / gridSize;\n  var regTileLatLen = 180 / gridSize;\n  var x1 = _x1 === undefined ? gridSize - 1 : _x1;\n  var y1 = _y1 === undefined ? gridSize - 1 : _y1;\n  for (var x = x0, maxX = Math.min(gridSize - 1, x1); x <= maxX; x++) {\n    for (var y = y0, maxY = Math.min(gridSize - 1, y1); y <= maxY; y++) {\n      var reproY = y,\n        tileLatLen = regTileLatLen;\n      if (isMercator) {\n        // lat needs reprojection, but stretch to cover poles\n        reproY = y === 0 ? y : yMercatorScaleInvert(y / gridSize) * gridSize;\n        var reproYEnd = y + 1 === gridSize ? y + 1 : yMercatorScaleInvert((y + 1) / gridSize) * gridSize;\n        tileLatLen = (reproYEnd - reproY) * 180 / gridSize;\n      }\n\n      // tile centroid coordinates\n      var lng = -180 + (x + 0.5) * tileLngLen;\n      var lat = 90 - (reproY * 180 / gridSize + tileLatLen / 2);\n      var latLen = tileLatLen; // lng is always constant among all tiles\n\n      tiles.push({\n        x: x,\n        y: y,\n        lng: lng,\n        lat: lat,\n        latLen: latLen\n      });\n    }\n  }\n  return tiles;\n};\n\nvar MAX_LEVEL_TO_RENDER_ALL_TILES = 6; // level 6 = 4096 tiles\nvar MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE = 7; // octrees consume too much memory on higher levels, generate tiles on demand for those (based on globe surface distance) as the distortion is negligible\nvar TILE_SEARCH_RADIUS_CAMERA_DISTANCE = 3; // Euclidean distance factor, in units of camera distance to surface\nvar TILE_SEARCH_RADIUS_SURFACE_DISTANCE = 90; // in degrees on the globe surface, relative to camera altitude in globe radius units\nvar _radius = /*#__PURE__*/new WeakMap();\nvar _isMercator = /*#__PURE__*/new WeakMap();\nvar _tileUrl = /*#__PURE__*/new WeakMap();\nvar _level = /*#__PURE__*/new WeakMap();\nvar _tilesMeta = /*#__PURE__*/new WeakMap();\nvar _isInView = /*#__PURE__*/new WeakMap();\nvar _camera = /*#__PURE__*/new WeakMap();\nvar _innerBackLayer = /*#__PURE__*/new WeakMap();\nvar _ThreeSlippyMapGlobe_brand = /*#__PURE__*/new WeakSet();\nvar ThreeSlippyMapGlobe = /*#__PURE__*/function (_Group) {\n  function ThreeSlippyMapGlobe(radius) {\n    var _this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      tileUrl = _ref.tileUrl,\n      _ref$minLevel = _ref.minLevel,\n      minLevel = _ref$minLevel === void 0 ? 0 : _ref$minLevel,\n      _ref$maxLevel = _ref.maxLevel,\n      maxLevel = _ref$maxLevel === void 0 ? 17 : _ref$maxLevel,\n      _ref$mercatorProjecti = _ref.mercatorProjection,\n      mercatorProjection = _ref$mercatorProjecti === void 0 ? true : _ref$mercatorProjecti;\n    _classCallCheck(this, ThreeSlippyMapGlobe);\n    _this = _callSuper(this, ThreeSlippyMapGlobe);\n    // Private methods\n    _classPrivateMethodInitSpec(_this, _ThreeSlippyMapGlobe_brand);\n    // Private attributes\n    _classPrivateFieldInitSpec(_this, _radius, void 0);\n    _classPrivateFieldInitSpec(_this, _isMercator, void 0);\n    _classPrivateFieldInitSpec(_this, _tileUrl, void 0);\n    _classPrivateFieldInitSpec(_this, _level, void 0);\n    _classPrivateFieldInitSpec(_this, _tilesMeta, {});\n    _classPrivateFieldInitSpec(_this, _isInView, void 0);\n    _classPrivateFieldInitSpec(_this, _camera, void 0);\n    _classPrivateFieldInitSpec(_this, _innerBackLayer, void 0);\n    _defineProperty(_this, \"minLevel\", void 0);\n    _defineProperty(_this, \"maxLevel\", void 0);\n    _defineProperty(_this, \"thresholds\", _toConsumableArray(new Array(30)).map(function (_, idx) {\n      return 8 / Math.pow(2, idx);\n    }));\n    // in terms of radius units\n    _defineProperty(_this, \"curvatureResolution\", 5);\n    // in degrees, affects number of vertices in tiles\n    _defineProperty(_this, \"tileMargin\", 0);\n    _defineProperty(_this, \"clearTiles\", function () {\n      Object.values(_classPrivateFieldGet2(_tilesMeta, _this)).forEach(function (l) {\n        l.forEach(function (d) {\n          if (d.obj) {\n            _this.remove(d.obj);\n            emptyObject(d.obj);\n            delete d.obj;\n          }\n        });\n      });\n      _classPrivateFieldSet2(_tilesMeta, _this, {});\n    });\n    _classPrivateFieldSet2(_radius, _this, radius);\n    _this.tileUrl = tileUrl;\n    _classPrivateFieldSet2(_isMercator, _this, mercatorProjection);\n    _this.minLevel = minLevel;\n    _this.maxLevel = maxLevel;\n    _this.level = 0;\n\n    // Add protective black sphere just below surface to prevent any depth buffer anomalies\n    _this.add(_classPrivateFieldSet2(_innerBackLayer, _this, new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this) * 0.99, 180, 90), new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n      color: 0x0\n    }))));\n    _classPrivateFieldGet2(_innerBackLayer, _this).visible = false;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffset = true;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetUnits = 3;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetFactor = 1;\n    return _this;\n  }\n  _inherits(ThreeSlippyMapGlobe, _Group);\n  return _createClass(ThreeSlippyMapGlobe, [{\n    key: \"tileUrl\",\n    get:\n    // Public attributes\n    function get() {\n      return _classPrivateFieldGet2(_tileUrl, this);\n    },\n    set: function set(tileUrl) {\n      _classPrivateFieldSet2(_tileUrl, this, tileUrl);\n      this.updatePov(_classPrivateFieldGet2(_camera, this)); // update current view\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return _classPrivateFieldGet2(_level, this);\n    },\n    set: function set(level) {\n      var _classPrivateFieldGet2$1,\n        _this2 = this;\n      if (!_classPrivateFieldGet2(_tilesMeta, this)[level]) _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _buildMetaLevel).call(this, level);\n      var prevLevel = _classPrivateFieldGet2(_level, this);\n      _classPrivateFieldSet2(_level, this, level);\n      if (level === prevLevel || prevLevel === undefined) return; // nothing else to do\n\n      // Activate back layer for levels > 0, when there's !depthWrite tiles\n      _classPrivateFieldGet2(_innerBackLayer, this).visible = level > 0;\n\n      // Bring layer to front\n      _classPrivateFieldGet2(_tilesMeta, this)[level].forEach(function (d) {\n        return d.obj && (d.obj.material.depthWrite = true);\n      });\n\n      // push lower layers to background\n      prevLevel < level && ((_classPrivateFieldGet2$1 = _classPrivateFieldGet2(_tilesMeta, this)[prevLevel]) === null || _classPrivateFieldGet2$1 === void 0 ? void 0 : _classPrivateFieldGet2$1.forEach(function (d) {\n        return d.obj && (d.obj.material.depthWrite = false);\n      }));\n\n      // Remove upper layers\n      if (prevLevel > level) {\n        for (var l = level + 1; l <= prevLevel; l++) {\n          _classPrivateFieldGet2(_tilesMeta, this)[l] && _classPrivateFieldGet2(_tilesMeta, this)[l].forEach(function (d) {\n            if (d.obj) {\n              _this2.remove(d.obj);\n              emptyObject(d.obj);\n              delete d.obj;\n            }\n          });\n        }\n      }\n      _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n    }\n\n    // Public methods\n  }, {\n    key: \"updatePov\",\n    value: function updatePov(camera) {\n      var _this3 = this;\n      if (!camera || !(camera instanceof three__WEBPACK_IMPORTED_MODULE_2__.Camera)) return;\n      _classPrivateFieldSet2(_camera, this, camera);\n      var frustum;\n      _classPrivateFieldSet2(_isInView, this, function (d) {\n        if (!d.hullPnts) {\n          // cached for next time to improve performance\n          var lngLen = 360 / Math.pow(2, _this3.level);\n          var lng = d.lng,\n            lat = d.lat,\n            latLen = d.latLen;\n          var lng0 = lng - lngLen / 2;\n          var lng1 = lng + lngLen / 2;\n          var lat0 = lat - latLen / 2;\n          var lat1 = lat + latLen / 2;\n          d.hullPnts = [[lat, lng], [lat0, lng0], [lat1, lng0], [lat0, lng1], [lat1, lng1]].map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n              lat = _ref3[0],\n              lng = _ref3[1];\n            return polar2Cartesian(lat, lng, _classPrivateFieldGet2(_radius, _this3));\n          }).map(function (_ref4) {\n            var x = _ref4.x,\n              y = _ref4.y,\n              z = _ref4.z;\n            return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n          });\n        }\n        if (!frustum) {\n          frustum = new three__WEBPACK_IMPORTED_MODULE_2__.Frustum();\n          camera.updateMatrix();\n          camera.updateMatrixWorld();\n          frustum.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\n        }\n        return d.hullPnts.some(function (pos) {\n          return frustum.containsPoint(pos.clone().applyMatrix4(_this3.matrixWorld));\n        });\n      });\n      if (this.tileUrl) {\n        var pov = camera.position.clone();\n        var distToGlobeCenter = pov.distanceTo(this.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()));\n        var cameraDistance = (distToGlobeCenter - _classPrivateFieldGet2(_radius, this)) / _classPrivateFieldGet2(_radius, this); // in units of globe radius\n\n        var idx = this.thresholds.findIndex(function (t) {\n          return t && t <= cameraDistance;\n        });\n        this.level = Math.min(this.maxLevel, Math.max(this.minLevel, idx < 0 ? this.thresholds.length : idx));\n        _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n      }\n    }\n  }]);\n}(three__WEBPACK_IMPORTED_MODULE_2__.Group);\nfunction _buildMetaLevel(level) {\n  var _this4 = this;\n  if (level > MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE) {\n    // Generate meta dynamically\n    _classPrivateFieldGet2(_tilesMeta, this)[level] = [];\n    return;\n  }\n\n  // Generate distance lookup octree\n  var levelMeta = _classPrivateFieldGet2(_tilesMeta, this)[level] = genTilesCoords(level, _classPrivateFieldGet2(_isMercator, this));\n  levelMeta.forEach(function (d) {\n    return d.centroid = polar2Cartesian(d.lat, d.lng, _classPrivateFieldGet2(_radius, _this4));\n  });\n  levelMeta.octree = (0,d3_octree__WEBPACK_IMPORTED_MODULE_3__[\"default\"])().x(function (d) {\n    return d.centroid.x;\n  }).y(function (d) {\n    return d.centroid.y;\n  }).z(function (d) {\n    return d.centroid.z;\n  }).addAll(levelMeta);\n}\nfunction _fetchNeededTiles() {\n  var _this5 = this;\n  if (!this.tileUrl || this.level === undefined || !_classPrivateFieldGet2(_tilesMeta, this).hasOwnProperty(this.level)) return;\n\n  // Safety if can't check in view tiles for higher levels\n  if (!_classPrivateFieldGet2(_isInView, this) && this.level > MAX_LEVEL_TO_RENDER_ALL_TILES) return;\n  var tiles = _classPrivateFieldGet2(_tilesMeta, this)[this.level];\n  if (_classPrivateFieldGet2(_camera, this)) {\n    // Pre-select tiles close to the camera\n    var povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n    if (tiles.octree) {\n      var _tiles$octree;\n      // Octree based on 3d positions is more accurate\n      var _povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n      var searchRadius = (_povPos.length() - _classPrivateFieldGet2(_radius, this)) * TILE_SEARCH_RADIUS_CAMERA_DISTANCE;\n      tiles = (_tiles$octree = tiles.octree).findAllWithinRadius.apply(_tiles$octree, _toConsumableArray(_povPos).concat([searchRadius]));\n    } else {\n      // tiles populated dynamically\n      var povCoords = cartesian2Polar(povPos);\n      var searchRadiusLat = (povCoords.r / _classPrivateFieldGet2(_radius, this) - 1) * TILE_SEARCH_RADIUS_SURFACE_DISTANCE;\n      var searchRadiusLng = searchRadiusLat / Math.cos(deg2Rad(povCoords.lat)); // Distances in longitude degrees shrink towards the poles\n      var lngRange = [povCoords.lng - searchRadiusLng, povCoords.lng + searchRadiusLng];\n      var latRange = [povCoords.lat + searchRadiusLat, povCoords.lat - searchRadiusLat];\n      var _findTileXY = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[0], latRange[0]),\n        _findTileXY2 = _slicedToArray(_findTileXY, 2),\n        x0 = _findTileXY2[0],\n        y0 = _findTileXY2[1];\n      var _findTileXY3 = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[1], latRange[1]),\n        _findTileXY4 = _slicedToArray(_findTileXY3, 2),\n        x1 = _findTileXY4[0],\n        y1 = _findTileXY4[1];\n      !tiles.record && (tiles.record = {}); // Index gen tiles by XY\n      var r = tiles.record;\n      if (!r.hasOwnProperty(\"\".concat(Math.round((x0 + x1) / 2), \"_\").concat(Math.round((y0 + y1) / 2)))) {\n        // gen all found tiles if middle one is not in record\n        tiles = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x0, y0, x1, y1).map(function (d) {\n          var k = \"\".concat(d.x, \"_\").concat(d.y);\n          if (r.hasOwnProperty(k)) return r[k];\n          r[k] = d;\n          tiles.push(d);\n          return d;\n        });\n      } else {\n        // gen only those missing, one by one\n        var selTiles = [];\n        for (var x = x0; x <= x1; x++) {\n          for (var y = y0; y <= y1; y++) {\n            var k = \"\".concat(x, \"_\").concat(y);\n            if (!r.hasOwnProperty(k)) {\n              r[k] = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x, y, x, y)[0];\n              tiles.push(r[k]);\n            }\n            selTiles.push(r[k]);\n          }\n        }\n        tiles = selTiles;\n      }\n    }\n  }\n\n  /*\n  console.log({\n    level: this.level,\n    totalObjs: this.children.length,\n    tilesFound: tiles.length,\n    tilesInView: tiles.filter(this.#isInView || (() => true)).length,\n    levelTiles: this.#tilesMeta[this.level].length,\n    fetched: this.#tilesMeta[this.level].filter(d => d.obj).length,\n    loading: this.#tilesMeta[this.level].filter(d => d.loading).length,\n  });\n  */\n\n  tiles.filter(function (d) {\n    return !d.obj;\n  }).filter(_classPrivateFieldGet2(_isInView, this) || function () {\n    return true;\n  }).forEach(function (d) {\n    var x = d.x,\n      y = d.y,\n      lng = d.lng,\n      lat = d.lat,\n      latLen = d.latLen;\n    var lngLen = 360 / Math.pow(2, _this5.level);\n    if (!d.obj) {\n      var width = lngLen * (1 - _this5.tileMargin);\n      var height = latLen * (1 - _this5.tileMargin);\n      var rotLng = deg2Rad(lng);\n      var rotLat = deg2Rad(-lat);\n      var tile = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this5), Math.ceil(width / _this5.curvatureResolution), Math.ceil(height / _this5.curvatureResolution), deg2Rad(90 - width / 2) + rotLng, deg2Rad(width), deg2Rad(90 - height / 2) + rotLat, deg2Rad(height)), new three__WEBPACK_IMPORTED_MODULE_2__.MeshLambertMaterial());\n      if (_classPrivateFieldGet2(_isMercator, _this5)) {\n        var _map = [lat + latLen / 2, lat - latLen / 2].map(function (lat) {\n            return 0.5 - lat / 180;\n          }),\n          _map2 = _slicedToArray(_map, 2),\n          _y = _map2[0],\n          _y2 = _map2[1];\n        convertMercatorUV(tile.geometry.attributes.uv, _y, _y2);\n      }\n      d.obj = tile;\n    }\n    if (!d.loading) {\n      d.loading = true;\n\n      // Fetch tile image\n      new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(_this5.tileUrl(x, y, _this5.level), function (texture) {\n        var tile = d.obj;\n        if (tile) {\n          texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_2__.SRGBColorSpace;\n          tile.material.map = texture;\n          tile.material.color = null;\n          tile.material.needsUpdate = true;\n          _this5.add(tile);\n        }\n        d.loading = false;\n      });\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc2xpcHB5LW1hcC1nbG9iZS9kaXN0L3RocmVlLXNsaXBweS1tYXAtZ2xvYmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThKO0FBQzNIO0FBQ0k7QUFDQzs7QUFFeEM7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZLGtFQUFrRTtBQUM3SCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QUNBLHFCQUFxQix1Q0FBSSxLQUFLLGlEQUFjLG9QQUFvUCxzREFBbUI7QUFDblQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsZ0RBQWE7QUFDdkI7QUFDQTtBQUNBLCtCQUErQixpREFBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRTBDIiwic291cmNlcyI6WyJEOlxcU3R1ZHkgU3R1ZmZcXFNlbWVzdGVyXFxQcm9qZWN0c1xcNXRoIFNlbWVzdGVyXFxEVlxcRmluYWwgRGFzaGJvYXJkXFxGb3JrZWRcXGR2X2Rhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFx0aHJlZS1zbGlwcHktbWFwLWdsb2JlXFxkaXN0XFx0aHJlZS1zbGlwcHktbWFwLWdsb2JlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW1lcmEsIFZlY3RvcjMsIEdyb3VwLCBNZXNoLCBTcGhlcmVHZW9tZXRyeSwgTWVzaEJhc2ljTWF0ZXJpYWwsIEZydXN0dW0sIE1hdHJpeDQsIE1lc2hMYW1iZXJ0TWF0ZXJpYWwsIFRleHR1cmVMb2FkZXIsIFNSR0JDb2xvclNwYWNlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgb2N0cmVlIH0gZnJvbSAnZDMtb2N0cmVlJztcbmltcG9ydCB7IHNjYWxlTGluZWFyIH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgZ2VvTWVyY2F0b3JSYXcgfSBmcm9tICdkMy1nZW8nO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkge1xuICByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpIHtcbiAgaWYgKHQuaGFzKGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgdGhlIHNhbWUgcHJpdmF0ZSBlbGVtZW50cyB0d2ljZSBvbiBhbiBvYmplY3RcIik7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRHZXQyKHMsIGEpIHtcbiAgcmV0dXJuIHMuZ2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKGUsIHQsIGEpIHtcbiAgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihzLCBhLCByKSB7XG4gIHJldHVybiBzLnNldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSwgciksIHI7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMoZSwgYSkge1xuICBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCBhKSwgYS5hZGQoZSk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgZmFsc2UsIG8uY29uZmlndXJhYmxlID0gdHJ1ZSwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSB0cnVlKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIDsgZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoU3RyaW5nICkodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBfbWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gbWF0ZXJpYWxEaXNwb3NlKG1hdGVyaWFsKSB7XG4gIGlmIChtYXRlcmlhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWF0ZXJpYWwuZm9yRWFjaChfbWF0ZXJpYWxEaXNwb3NlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICBtYXRlcmlhbC5tYXAuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBtYXRlcmlhbC5kaXNwb3NlKCk7XG4gIH1cbn07XG52YXIgX2RlYWxsb2NhdGUgPSBmdW5jdGlvbiBkZWFsbG9jYXRlKG9iaikge1xuICBpZiAob2JqLmdlb21ldHJ5KSB7XG4gICAgb2JqLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLm1hdGVyaWFsKSB7XG4gICAgX21hdGVyaWFsRGlzcG9zZShvYmoubWF0ZXJpYWwpO1xuICB9XG4gIGlmIChvYmoudGV4dHVyZSkge1xuICAgIG9iai50ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgfVxuICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgb2JqLmNoaWxkcmVuLmZvckVhY2goX2RlYWxsb2NhdGUpO1xuICB9XG59O1xudmFyIGVtcHR5T2JqZWN0ID0gZnVuY3Rpb24gZW1wdHlPYmplY3Qob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLmNoaWxkcmVuKSB3aGlsZSAob2JqLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBjaGlsZE9iaiA9IG9iai5jaGlsZHJlblswXTtcbiAgICBvYmoucmVtb3ZlKGNoaWxkT2JqKTtcbiAgICBfZGVhbGxvY2F0ZShjaGlsZE9iaik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgcikge1xuICB2YXIgcGhpID0gKDkwIC0gbGF0KSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciB0aGV0YSA9ICg5MCAtIGxuZykgKiBNYXRoLlBJIC8gMTgwO1xuICByZXR1cm4ge1xuICAgIHg6IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHIgKiBNYXRoLmNvcyhwaGkpLFxuICAgIHo6IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpXG4gIH07XG59XG5mdW5jdGlvbiBjYXJ0ZXNpYW4yUG9sYXIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICB5ID0gX3JlZi55LFxuICAgIHogPSBfcmVmLno7XG4gIHZhciByID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciBwaGkgPSBNYXRoLmFjb3MoeSAvIHIpO1xuICB2YXIgdGhldGEgPSBNYXRoLmF0YW4yKHosIHgpO1xuICByZXR1cm4ge1xuICAgIGxhdDogOTAgLSBwaGkgKiAxODAgLyBNYXRoLlBJLFxuICAgIGxuZzogOTAgLSB0aGV0YSAqIDE4MCAvIE1hdGguUEkgLSAodGhldGEgPCAtTWF0aC5QSSAvIDIgPyAzNjAgOiAwKSxcbiAgICAvLyBrZWVwIHdpdGhpbiBbLTE4MCwgMTgwXSBib3VuZGFyaWVzXG4gICAgcjogclxuICB9O1xufVxuZnVuY3Rpb24gZGVnMlJhZChkZWcpIHtcbiAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG59XG5cbnZhciB5TWVyY2F0b3JTY2FsZSA9IGZ1bmN0aW9uIHlNZXJjYXRvclNjYWxlKHkpIHtcbiAgcmV0dXJuIDEgLSAoZ2VvTWVyY2F0b3JSYXcoMCwgKDAuNSAtIHkpICogTWF0aC5QSSlbMV0gLyBNYXRoLlBJICsgMSkgLyAyO1xufTtcbnZhciB5TWVyY2F0b3JTY2FsZUNsYW1wZWQgPSBmdW5jdGlvbiB5TWVyY2F0b3JTY2FsZUNsYW1wZWQoeSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeU1lcmNhdG9yU2NhbGUoeSkpKTtcbn07XG52YXIgeU1lcmNhdG9yU2NhbGVJbnZlcnQgPSBmdW5jdGlvbiB5TWVyY2F0b3JTY2FsZUludmVydCh5KSB7XG4gIHJldHVybiAwLjUgLSBnZW9NZXJjYXRvclJhdy5pbnZlcnQoMCwgKDIgKiAoMSAtIHkpIC0gMSkgKiBNYXRoLlBJKVsxXSAvIE1hdGguUEk7XG59O1xudmFyIGNvbnZlcnRNZXJjYXRvclVWID0gZnVuY3Rpb24gY29udmVydE1lcmNhdG9yVVYodXZzKSB7XG4gIHZhciB5MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgb2Zmc2V0U2NhbGUgPSBzY2FsZUxpbmVhcigpLmRvbWFpbihbMSwgMF0pLnJhbmdlKFt5MCwgeTFdKS5jbGFtcCh0cnVlKTtcbiAgdmFyIHJldk9mZnNldFNjYWxlID0gc2NhbGVMaW5lYXIoKS5kb21haW4oW3lNZXJjYXRvclNjYWxlQ2xhbXBlZCh5MCksIHlNZXJjYXRvclNjYWxlQ2xhbXBlZCh5MSldKS5yYW5nZShbMSwgMF0pLmNsYW1wKHRydWUpO1xuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2KSB7XG4gICAgcmV0dXJuIHJldk9mZnNldFNjYWxlKHlNZXJjYXRvclNjYWxlQ2xhbXBlZChvZmZzZXRTY2FsZSh2KSkpO1xuICB9O1xuICB2YXIgYXJyID0gdXZzLmFycmF5O1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgYXJyW2kgKyAxXSA9IHNjYWxlKGFycltpICsgMV0pO1xuICB9XG4gIHV2cy5uZWVkc1VwZGF0ZSA9IHRydWU7XG59O1xuXG52YXIgZmluZFRpbGVYWSA9IGZ1bmN0aW9uIGZpbmRUaWxlWFkobGV2ZWwsIGlzTWVyY2F0b3IsIGxuZywgbGF0KSB7XG4gIHZhciBncmlkU2l6ZSA9IE1hdGgucG93KDIsIGxldmVsKTtcbiAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIE1hdGguZmxvb3IoKGxuZyArIDE4MCkgKiBncmlkU2l6ZSAvIDM2MCkpKTtcbiAgdmFyIHJlbFkgPSAoOTAgLSBsYXQpIC8gMTgwO1xuICBpc01lcmNhdG9yICYmIChyZWxZID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeU1lcmNhdG9yU2NhbGUocmVsWSkpKSk7XG4gIHZhciB5ID0gTWF0aC5mbG9vcihyZWxZICogZ3JpZFNpemUpO1xuICByZXR1cm4gW3gsIHldO1xufTtcbnZhciBnZW5UaWxlc0Nvb3JkcyA9IGZ1bmN0aW9uIGdlblRpbGVzQ29vcmRzKGxldmVsLCBpc01lcmNhdG9yKSB7XG4gIHZhciB4MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgdmFyIHkwID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICB2YXIgX3gxID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gIHZhciBfeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRpbGVzID0gW107XG4gIHZhciBncmlkU2l6ZSA9IE1hdGgucG93KDIsIGxldmVsKTtcbiAgdmFyIHRpbGVMbmdMZW4gPSAzNjAgLyBncmlkU2l6ZTtcbiAgdmFyIHJlZ1RpbGVMYXRMZW4gPSAxODAgLyBncmlkU2l6ZTtcbiAgdmFyIHgxID0gX3gxID09PSB1bmRlZmluZWQgPyBncmlkU2l6ZSAtIDEgOiBfeDE7XG4gIHZhciB5MSA9IF95MSA9PT0gdW5kZWZpbmVkID8gZ3JpZFNpemUgLSAxIDogX3kxO1xuICBmb3IgKHZhciB4ID0geDAsIG1heFggPSBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIHgxKTsgeCA8PSBtYXhYOyB4KyspIHtcbiAgICBmb3IgKHZhciB5ID0geTAsIG1heFkgPSBNYXRoLm1pbihncmlkU2l6ZSAtIDEsIHkxKTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIHZhciByZXByb1kgPSB5LFxuICAgICAgICB0aWxlTGF0TGVuID0gcmVnVGlsZUxhdExlbjtcbiAgICAgIGlmIChpc01lcmNhdG9yKSB7XG4gICAgICAgIC8vIGxhdCBuZWVkcyByZXByb2plY3Rpb24sIGJ1dCBzdHJldGNoIHRvIGNvdmVyIHBvbGVzXG4gICAgICAgIHJlcHJvWSA9IHkgPT09IDAgPyB5IDogeU1lcmNhdG9yU2NhbGVJbnZlcnQoeSAvIGdyaWRTaXplKSAqIGdyaWRTaXplO1xuICAgICAgICB2YXIgcmVwcm9ZRW5kID0geSArIDEgPT09IGdyaWRTaXplID8geSArIDEgOiB5TWVyY2F0b3JTY2FsZUludmVydCgoeSArIDEpIC8gZ3JpZFNpemUpICogZ3JpZFNpemU7XG4gICAgICAgIHRpbGVMYXRMZW4gPSAocmVwcm9ZRW5kIC0gcmVwcm9ZKSAqIDE4MCAvIGdyaWRTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyB0aWxlIGNlbnRyb2lkIGNvb3JkaW5hdGVzXG4gICAgICB2YXIgbG5nID0gLTE4MCArICh4ICsgMC41KSAqIHRpbGVMbmdMZW47XG4gICAgICB2YXIgbGF0ID0gOTAgLSAocmVwcm9ZICogMTgwIC8gZ3JpZFNpemUgKyB0aWxlTGF0TGVuIC8gMik7XG4gICAgICB2YXIgbGF0TGVuID0gdGlsZUxhdExlbjsgLy8gbG5nIGlzIGFsd2F5cyBjb25zdGFudCBhbW9uZyBhbGwgdGlsZXNcblxuICAgICAgdGlsZXMucHVzaCh7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIGxuZzogbG5nLFxuICAgICAgICBsYXQ6IGxhdCxcbiAgICAgICAgbGF0TGVuOiBsYXRMZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlsZXM7XG59O1xuXG52YXIgTUFYX0xFVkVMX1RPX1JFTkRFUl9BTExfVElMRVMgPSA2OyAvLyBsZXZlbCA2ID0gNDA5NiB0aWxlc1xudmFyIE1BWF9MRVZFTF9UT19CVUlMRF9MT09LVVBfT0NUUkVFID0gNzsgLy8gb2N0cmVlcyBjb25zdW1lIHRvbyBtdWNoIG1lbW9yeSBvbiBoaWdoZXIgbGV2ZWxzLCBnZW5lcmF0ZSB0aWxlcyBvbiBkZW1hbmQgZm9yIHRob3NlIChiYXNlZCBvbiBnbG9iZSBzdXJmYWNlIGRpc3RhbmNlKSBhcyB0aGUgZGlzdG9ydGlvbiBpcyBuZWdsaWdpYmxlXG52YXIgVElMRV9TRUFSQ0hfUkFESVVTX0NBTUVSQV9ESVNUQU5DRSA9IDM7IC8vIEV1Y2xpZGVhbiBkaXN0YW5jZSBmYWN0b3IsIGluIHVuaXRzIG9mIGNhbWVyYSBkaXN0YW5jZSB0byBzdXJmYWNlXG52YXIgVElMRV9TRUFSQ0hfUkFESVVTX1NVUkZBQ0VfRElTVEFOQ0UgPSA5MDsgLy8gaW4gZGVncmVlcyBvbiB0aGUgZ2xvYmUgc3VyZmFjZSwgcmVsYXRpdmUgdG8gY2FtZXJhIGFsdGl0dWRlIGluIGdsb2JlIHJhZGl1cyB1bml0c1xudmFyIF9yYWRpdXMgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfaXNNZXJjYXRvciA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF90aWxlVXJsID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX2xldmVsID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX3RpbGVzTWV0YSA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9pc0luVmlldyA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9jYW1lcmEgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfaW5uZXJCYWNrTGF5ZXIgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfVGhyZWVTbGlwcHlNYXBHbG9iZV9icmFuZCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xudmFyIFRocmVlU2xpcHB5TWFwR2xvYmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Hcm91cCkge1xuICBmdW5jdGlvbiBUaHJlZVNsaXBweU1hcEdsb2JlKHJhZGl1cykge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICB0aWxlVXJsID0gX3JlZi50aWxlVXJsLFxuICAgICAgX3JlZiRtaW5MZXZlbCA9IF9yZWYubWluTGV2ZWwsXG4gICAgICBtaW5MZXZlbCA9IF9yZWYkbWluTGV2ZWwgPT09IHZvaWQgMCA/IDAgOiBfcmVmJG1pbkxldmVsLFxuICAgICAgX3JlZiRtYXhMZXZlbCA9IF9yZWYubWF4TGV2ZWwsXG4gICAgICBtYXhMZXZlbCA9IF9yZWYkbWF4TGV2ZWwgPT09IHZvaWQgMCA/IDE3IDogX3JlZiRtYXhMZXZlbCxcbiAgICAgIF9yZWYkbWVyY2F0b3JQcm9qZWN0aSA9IF9yZWYubWVyY2F0b3JQcm9qZWN0aW9uLFxuICAgICAgbWVyY2F0b3JQcm9qZWN0aW9uID0gX3JlZiRtZXJjYXRvclByb2plY3RpID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRtZXJjYXRvclByb2plY3RpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaHJlZVNsaXBweU1hcEdsb2JlKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVGhyZWVTbGlwcHlNYXBHbG9iZSk7XG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzXG4gICAgX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKF90aGlzLCBfVGhyZWVTbGlwcHlNYXBHbG9iZV9icmFuZCk7XG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzXG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9yYWRpdXMsIHZvaWQgMCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9pc01lcmNhdG9yLCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfdGlsZVVybCwgdm9pZCAwKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2xldmVsLCB2b2lkIDApO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfdGlsZXNNZXRhLCB7fSk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF9pc0luVmlldywgdm9pZCAwKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2NhbWVyYSwgdm9pZCAwKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2lubmVyQmFja0xheWVyLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaW5MZXZlbFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXhMZXZlbFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0aHJlc2hvbGRzXCIsIF90b0NvbnN1bWFibGVBcnJheShuZXcgQXJyYXkoMzApKS5tYXAoZnVuY3Rpb24gKF8sIGlkeCkge1xuICAgICAgcmV0dXJuIDggLyBNYXRoLnBvdygyLCBpZHgpO1xuICAgIH0pKTtcbiAgICAvLyBpbiB0ZXJtcyBvZiByYWRpdXMgdW5pdHNcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY3VydmF0dXJlUmVzb2x1dGlvblwiLCA1KTtcbiAgICAvLyBpbiBkZWdyZWVzLCBhZmZlY3RzIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aWxlc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0aWxlTWFyZ2luXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjbGVhclRpbGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCBfdGhpcykpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGQub2JqKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmUoZC5vYmopO1xuICAgICAgICAgICAgZW1wdHlPYmplY3QoZC5vYmopO1xuICAgICAgICAgICAgZGVsZXRlIGQub2JqO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX3RpbGVzTWV0YSwgX3RoaXMsIHt9KTtcbiAgICB9KTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9yYWRpdXMsIF90aGlzLCByYWRpdXMpO1xuICAgIF90aGlzLnRpbGVVcmwgPSB0aWxlVXJsO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX2lzTWVyY2F0b3IsIF90aGlzLCBtZXJjYXRvclByb2plY3Rpb24pO1xuICAgIF90aGlzLm1pbkxldmVsID0gbWluTGV2ZWw7XG4gICAgX3RoaXMubWF4TGV2ZWwgPSBtYXhMZXZlbDtcbiAgICBfdGhpcy5sZXZlbCA9IDA7XG5cbiAgICAvLyBBZGQgcHJvdGVjdGl2ZSBibGFjayBzcGhlcmUganVzdCBiZWxvdyBzdXJmYWNlIHRvIHByZXZlbnQgYW55IGRlcHRoIGJ1ZmZlciBhbm9tYWxpZXNcbiAgICBfdGhpcy5hZGQoX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfaW5uZXJCYWNrTGF5ZXIsIF90aGlzLCBuZXcgTWVzaChuZXcgU3BoZXJlR2VvbWV0cnkoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCBfdGhpcykgKiAwLjk5LCAxODAsIDkwKSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweDBcbiAgICB9KSkpKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLnZpc2libGUgPSBmYWxzZTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLm1hdGVyaWFsLnBvbHlnb25PZmZzZXQgPSB0cnVlO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCBfdGhpcykubWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gMztcbiAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMpLm1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAxO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoVGhyZWVTbGlwcHlNYXBHbG9iZSwgX0dyb3VwKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUaHJlZVNsaXBweU1hcEdsb2JlLCBbe1xuICAgIGtleTogXCJ0aWxlVXJsXCIsXG4gICAgZ2V0OlxuICAgIC8vIFB1YmxpYyBhdHRyaWJ1dGVzXG4gICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVVcmwsIHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodGlsZVVybCkge1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfdGlsZVVybCwgdGhpcywgdGlsZVVybCk7XG4gICAgICB0aGlzLnVwZGF0ZVBvdihfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9jYW1lcmEsIHRoaXMpKTsgLy8gdXBkYXRlIGN1cnJlbnQgdmlld1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2xldmVsLCB0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICB2YXIgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiQxLFxuICAgICAgICBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xldmVsXSkgX2Fzc2VydENsYXNzQnJhbmQoX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQsIHRoaXMsIF9idWlsZE1ldGFMZXZlbCkuY2FsbCh0aGlzLCBsZXZlbCk7XG4gICAgICB2YXIgcHJldkxldmVsID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfbGV2ZWwsIHRoaXMpO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfbGV2ZWwsIHRoaXMsIGxldmVsKTtcbiAgICAgIGlmIChsZXZlbCA9PT0gcHJldkxldmVsIHx8IHByZXZMZXZlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG5vdGhpbmcgZWxzZSB0byBkb1xuXG4gICAgICAvLyBBY3RpdmF0ZSBiYWNrIGxheWVyIGZvciBsZXZlbHMgPiAwLCB3aGVuIHRoZXJlJ3MgIWRlcHRoV3JpdGUgdGlsZXNcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCB0aGlzKS52aXNpYmxlID0gbGV2ZWwgPiAwO1xuXG4gICAgICAvLyBCcmluZyBsYXllciB0byBmcm9udFxuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5vYmogJiYgKGQub2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwdXNoIGxvd2VyIGxheWVycyB0byBiYWNrZ3JvdW5kXG4gICAgICBwcmV2TGV2ZWwgPCBsZXZlbCAmJiAoKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIkMSA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbcHJldkxldmVsXSkgPT09IG51bGwgfHwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2xhc3NQcml2YXRlRmllbGRHZXQyJDEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5vYmogJiYgKGQub2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZSk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFJlbW92ZSB1cHBlciBsYXllcnNcbiAgICAgIGlmIChwcmV2TGV2ZWwgPiBsZXZlbCkge1xuICAgICAgICBmb3IgKHZhciBsID0gbGV2ZWwgKyAxOyBsIDw9IHByZXZMZXZlbDsgbCsrKSB7XG4gICAgICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsXSAmJiBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xdLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChkLm9iaikge1xuICAgICAgICAgICAgICBfdGhpczIucmVtb3ZlKGQub2JqKTtcbiAgICAgICAgICAgICAgZW1wdHlPYmplY3QoZC5vYmopO1xuICAgICAgICAgICAgICBkZWxldGUgZC5vYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9hc3NlcnRDbGFzc0JyYW5kKF9UaHJlZVNsaXBweU1hcEdsb2JlX2JyYW5kLCB0aGlzLCBfZmV0Y2hOZWVkZWRUaWxlcykuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWMgbWV0aG9kc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBvdlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQb3YoY2FtZXJhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghY2FtZXJhIHx8ICEoY2FtZXJhIGluc3RhbmNlb2YgQ2FtZXJhKSkgcmV0dXJuO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfY2FtZXJhLCB0aGlzLCBjYW1lcmEpO1xuICAgICAgdmFyIGZydXN0dW07XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9pc0luVmlldywgdGhpcywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKCFkLmh1bGxQbnRzKSB7XG4gICAgICAgICAgLy8gY2FjaGVkIGZvciBuZXh0IHRpbWUgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgICAgICAgIHZhciBsbmdMZW4gPSAzNjAgLyBNYXRoLnBvdygyLCBfdGhpczMubGV2ZWwpO1xuICAgICAgICAgIHZhciBsbmcgPSBkLmxuZyxcbiAgICAgICAgICAgIGxhdCA9IGQubGF0LFxuICAgICAgICAgICAgbGF0TGVuID0gZC5sYXRMZW47XG4gICAgICAgICAgdmFyIGxuZzAgPSBsbmcgLSBsbmdMZW4gLyAyO1xuICAgICAgICAgIHZhciBsbmcxID0gbG5nICsgbG5nTGVuIC8gMjtcbiAgICAgICAgICB2YXIgbGF0MCA9IGxhdCAtIGxhdExlbiAvIDI7XG4gICAgICAgICAgdmFyIGxhdDEgPSBsYXQgKyBsYXRMZW4gLyAyO1xuICAgICAgICAgIGQuaHVsbFBudHMgPSBbW2xhdCwgbG5nXSwgW2xhdDAsIGxuZzBdLCBbbGF0MSwgbG5nMF0sIFtsYXQwLCBsbmcxXSwgW2xhdDEsIGxuZzFdXS5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgICAgICAgICAgIGxhdCA9IF9yZWYzWzBdLFxuICAgICAgICAgICAgICBsbmcgPSBfcmVmM1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2xhcjJDYXJ0ZXNpYW4obGF0LCBsbmcsIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgX3RoaXMzKSk7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgICAgdmFyIHggPSBfcmVmNC54LFxuICAgICAgICAgICAgICB5ID0gX3JlZjQueSxcbiAgICAgICAgICAgICAgeiA9IF9yZWY0Lno7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoeCwgeSwgeik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmcnVzdHVtKSB7XG4gICAgICAgICAgZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG4gICAgICAgICAgY2FtZXJhLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICAgIGZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgobmV3IE1hdHJpeDQoKS5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQuaHVsbFBudHMuc29tZShmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgcmV0dXJuIGZydXN0dW0uY29udGFpbnNQb2ludChwb3MuY2xvbmUoKS5hcHBseU1hdHJpeDQoX3RoaXMzLm1hdHJpeFdvcmxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy50aWxlVXJsKSB7XG4gICAgICAgIHZhciBwb3YgPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgdmFyIGRpc3RUb0dsb2JlQ2VudGVyID0gcG92LmRpc3RhbmNlVG8odGhpcy5nZXRXb3JsZFBvc2l0aW9uKG5ldyBWZWN0b3IzKCkpKTtcbiAgICAgICAgdmFyIGNhbWVyYURpc3RhbmNlID0gKGRpc3RUb0dsb2JlQ2VudGVyIC0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCB0aGlzKSkgLyBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIHRoaXMpOyAvLyBpbiB1bml0cyBvZiBnbG9iZSByYWRpdXNcblxuICAgICAgICB2YXIgaWR4ID0gdGhpcy50aHJlc2hvbGRzLmZpbmRJbmRleChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0ICYmIHQgPD0gY2FtZXJhRGlzdGFuY2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxldmVsID0gTWF0aC5taW4odGhpcy5tYXhMZXZlbCwgTWF0aC5tYXgodGhpcy5taW5MZXZlbCwgaWR4IDwgMCA/IHRoaXMudGhyZXNob2xkcy5sZW5ndGggOiBpZHgpKTtcbiAgICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQsIHRoaXMsIF9mZXRjaE5lZWRlZFRpbGVzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufShHcm91cCk7XG5mdW5jdGlvbiBfYnVpbGRNZXRhTGV2ZWwobGV2ZWwpIHtcbiAgdmFyIF90aGlzNCA9IHRoaXM7XG4gIGlmIChsZXZlbCA+IE1BWF9MRVZFTF9UT19CVUlMRF9MT09LVVBfT0NUUkVFKSB7XG4gICAgLy8gR2VuZXJhdGUgbWV0YSBkeW5hbWljYWxseVxuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbbGV2ZWxdID0gW107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgZGlzdGFuY2UgbG9va3VwIG9jdHJlZVxuICB2YXIgbGV2ZWxNZXRhID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0gPSBnZW5UaWxlc0Nvb3JkcyhsZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcykpO1xuICBsZXZlbE1ldGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNlbnRyb2lkID0gcG9sYXIyQ2FydGVzaWFuKGQubGF0LCBkLmxuZywgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCBfdGhpczQpKTtcbiAgfSk7XG4gIGxldmVsTWV0YS5vY3RyZWUgPSBvY3RyZWUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuY2VudHJvaWQueDtcbiAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNlbnRyb2lkLnk7XG4gIH0pLnooZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5jZW50cm9pZC56O1xuICB9KS5hZGRBbGwobGV2ZWxNZXRhKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaE5lZWRlZFRpbGVzKCkge1xuICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgaWYgKCF0aGlzLnRpbGVVcmwgfHwgdGhpcy5sZXZlbCA9PT0gdW5kZWZpbmVkIHx8ICFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpLmhhc093blByb3BlcnR5KHRoaXMubGV2ZWwpKSByZXR1cm47XG5cbiAgLy8gU2FmZXR5IGlmIGNhbid0IGNoZWNrIGluIHZpZXcgdGlsZXMgZm9yIGhpZ2hlciBsZXZlbHNcbiAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc0luVmlldywgdGhpcykgJiYgdGhpcy5sZXZlbCA+IE1BWF9MRVZFTF9UT19SRU5ERVJfQUxMX1RJTEVTKSByZXR1cm47XG4gIHZhciB0aWxlcyA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbdGhpcy5sZXZlbF07XG4gIGlmIChfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9jYW1lcmEsIHRoaXMpKSB7XG4gICAgLy8gUHJlLXNlbGVjdCB0aWxlcyBjbG9zZSB0byB0aGUgY2FtZXJhXG4gICAgdmFyIHBvdlBvcyA9IHRoaXMud29ybGRUb0xvY2FsKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2NhbWVyYSwgdGhpcykucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgaWYgKHRpbGVzLm9jdHJlZSkge1xuICAgICAgdmFyIF90aWxlcyRvY3RyZWU7XG4gICAgICAvLyBPY3RyZWUgYmFzZWQgb24gM2QgcG9zaXRpb25zIGlzIG1vcmUgYWNjdXJhdGVcbiAgICAgIHZhciBfcG92UG9zID0gdGhpcy53b3JsZFRvTG9jYWwoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfY2FtZXJhLCB0aGlzKS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXMgPSAoX3BvdlBvcy5sZW5ndGgoKSAtIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgdGhpcykpICogVElMRV9TRUFSQ0hfUkFESVVTX0NBTUVSQV9ESVNUQU5DRTtcbiAgICAgIHRpbGVzID0gKF90aWxlcyRvY3RyZWUgPSB0aWxlcy5vY3RyZWUpLmZpbmRBbGxXaXRoaW5SYWRpdXMuYXBwbHkoX3RpbGVzJG9jdHJlZSwgX3RvQ29uc3VtYWJsZUFycmF5KF9wb3ZQb3MpLmNvbmNhdChbc2VhcmNoUmFkaXVzXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aWxlcyBwb3B1bGF0ZWQgZHluYW1pY2FsbHlcbiAgICAgIHZhciBwb3ZDb29yZHMgPSBjYXJ0ZXNpYW4yUG9sYXIocG92UG9zKTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXNMYXQgPSAocG92Q29vcmRzLnIgLyBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIHRoaXMpIC0gMSkgKiBUSUxFX1NFQVJDSF9SQURJVVNfU1VSRkFDRV9ESVNUQU5DRTtcbiAgICAgIHZhciBzZWFyY2hSYWRpdXNMbmcgPSBzZWFyY2hSYWRpdXNMYXQgLyBNYXRoLmNvcyhkZWcyUmFkKHBvdkNvb3Jkcy5sYXQpKTsgLy8gRGlzdGFuY2VzIGluIGxvbmdpdHVkZSBkZWdyZWVzIHNocmluayB0b3dhcmRzIHRoZSBwb2xlc1xuICAgICAgdmFyIGxuZ1JhbmdlID0gW3BvdkNvb3Jkcy5sbmcgLSBzZWFyY2hSYWRpdXNMbmcsIHBvdkNvb3Jkcy5sbmcgKyBzZWFyY2hSYWRpdXNMbmddO1xuICAgICAgdmFyIGxhdFJhbmdlID0gW3BvdkNvb3Jkcy5sYXQgKyBzZWFyY2hSYWRpdXNMYXQsIHBvdkNvb3Jkcy5sYXQgLSBzZWFyY2hSYWRpdXNMYXRdO1xuICAgICAgdmFyIF9maW5kVGlsZVhZID0gZmluZFRpbGVYWSh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgbG5nUmFuZ2VbMF0sIGxhdFJhbmdlWzBdKSxcbiAgICAgICAgX2ZpbmRUaWxlWFkyID0gX3NsaWNlZFRvQXJyYXkoX2ZpbmRUaWxlWFksIDIpLFxuICAgICAgICB4MCA9IF9maW5kVGlsZVhZMlswXSxcbiAgICAgICAgeTAgPSBfZmluZFRpbGVYWTJbMV07XG4gICAgICB2YXIgX2ZpbmRUaWxlWFkzID0gZmluZFRpbGVYWSh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgbG5nUmFuZ2VbMV0sIGxhdFJhbmdlWzFdKSxcbiAgICAgICAgX2ZpbmRUaWxlWFk0ID0gX3NsaWNlZFRvQXJyYXkoX2ZpbmRUaWxlWFkzLCAyKSxcbiAgICAgICAgeDEgPSBfZmluZFRpbGVYWTRbMF0sXG4gICAgICAgIHkxID0gX2ZpbmRUaWxlWFk0WzFdO1xuICAgICAgIXRpbGVzLnJlY29yZCAmJiAodGlsZXMucmVjb3JkID0ge30pOyAvLyBJbmRleCBnZW4gdGlsZXMgYnkgWFlcbiAgICAgIHZhciByID0gdGlsZXMucmVjb3JkO1xuICAgICAgaWYgKCFyLmhhc093blByb3BlcnR5KFwiXCIuY29uY2F0KE1hdGgucm91bmQoKHgwICsgeDEpIC8gMiksIFwiX1wiKS5jb25jYXQoTWF0aC5yb3VuZCgoeTAgKyB5MSkgLyAyKSkpKSB7XG4gICAgICAgIC8vIGdlbiBhbGwgZm91bmQgdGlsZXMgaWYgbWlkZGxlIG9uZSBpcyBub3QgaW4gcmVjb3JkXG4gICAgICAgIHRpbGVzID0gZ2VuVGlsZXNDb29yZHModGhpcy5sZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcyksIHgwLCB5MCwgeDEsIHkxKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2YXIgayA9IFwiXCIuY29uY2F0KGQueCwgXCJfXCIpLmNvbmNhdChkLnkpO1xuICAgICAgICAgIGlmIChyLmhhc093blByb3BlcnR5KGspKSByZXR1cm4gcltrXTtcbiAgICAgICAgICByW2tdID0gZDtcbiAgICAgICAgICB0aWxlcy5wdXNoKGQpO1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdlbiBvbmx5IHRob3NlIG1pc3NpbmcsIG9uZSBieSBvbmVcbiAgICAgICAgdmFyIHNlbFRpbGVzID0gW107XG4gICAgICAgIGZvciAodmFyIHggPSB4MDsgeCA8PSB4MTsgeCsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgeSA9IHkwOyB5IDw9IHkxOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBrID0gXCJcIi5jb25jYXQoeCwgXCJfXCIpLmNvbmNhdCh5KTtcbiAgICAgICAgICAgIGlmICghci5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICByW2tdID0gZ2VuVGlsZXNDb29yZHModGhpcy5sZXZlbCwgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgdGhpcyksIHgsIHksIHgsIHkpWzBdO1xuICAgICAgICAgICAgICB0aWxlcy5wdXNoKHJba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsVGlsZXMucHVzaChyW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGlsZXMgPSBzZWxUaWxlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICBjb25zb2xlLmxvZyh7XG4gICAgbGV2ZWw6IHRoaXMubGV2ZWwsXG4gICAgdG90YWxPYmpzOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCxcbiAgICB0aWxlc0ZvdW5kOiB0aWxlcy5sZW5ndGgsXG4gICAgdGlsZXNJblZpZXc6IHRpbGVzLmZpbHRlcih0aGlzLiNpc0luVmlldyB8fCAoKCkgPT4gdHJ1ZSkpLmxlbmd0aCxcbiAgICBsZXZlbFRpbGVzOiB0aGlzLiN0aWxlc01ldGFbdGhpcy5sZXZlbF0ubGVuZ3RoLFxuICAgIGZldGNoZWQ6IHRoaXMuI3RpbGVzTWV0YVt0aGlzLmxldmVsXS5maWx0ZXIoZCA9PiBkLm9iaikubGVuZ3RoLFxuICAgIGxvYWRpbmc6IHRoaXMuI3RpbGVzTWV0YVt0aGlzLmxldmVsXS5maWx0ZXIoZCA9PiBkLmxvYWRpbmcpLmxlbmd0aCxcbiAgfSk7XG4gICovXG5cbiAgdGlsZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuICFkLm9iajtcbiAgfSkuZmlsdGVyKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzSW5WaWV3LCB0aGlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgeCA9IGQueCxcbiAgICAgIHkgPSBkLnksXG4gICAgICBsbmcgPSBkLmxuZyxcbiAgICAgIGxhdCA9IGQubGF0LFxuICAgICAgbGF0TGVuID0gZC5sYXRMZW47XG4gICAgdmFyIGxuZ0xlbiA9IDM2MCAvIE1hdGgucG93KDIsIF90aGlzNS5sZXZlbCk7XG4gICAgaWYgKCFkLm9iaikge1xuICAgICAgdmFyIHdpZHRoID0gbG5nTGVuICogKDEgLSBfdGhpczUudGlsZU1hcmdpbik7XG4gICAgICB2YXIgaGVpZ2h0ID0gbGF0TGVuICogKDEgLSBfdGhpczUudGlsZU1hcmdpbik7XG4gICAgICB2YXIgcm90TG5nID0gZGVnMlJhZChsbmcpO1xuICAgICAgdmFyIHJvdExhdCA9IGRlZzJSYWQoLWxhdCk7XG4gICAgICB2YXIgdGlsZSA9IG5ldyBNZXNoKG5ldyBTcGhlcmVHZW9tZXRyeShfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIF90aGlzNSksIE1hdGguY2VpbCh3aWR0aCAvIF90aGlzNS5jdXJ2YXR1cmVSZXNvbHV0aW9uKSwgTWF0aC5jZWlsKGhlaWdodCAvIF90aGlzNS5jdXJ2YXR1cmVSZXNvbHV0aW9uKSwgZGVnMlJhZCg5MCAtIHdpZHRoIC8gMikgKyByb3RMbmcsIGRlZzJSYWQod2lkdGgpLCBkZWcyUmFkKDkwIC0gaGVpZ2h0IC8gMikgKyByb3RMYXQsIGRlZzJSYWQoaGVpZ2h0KSksIG5ldyBNZXNoTGFtYmVydE1hdGVyaWFsKCkpO1xuICAgICAgaWYgKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzTWVyY2F0b3IsIF90aGlzNSkpIHtcbiAgICAgICAgdmFyIF9tYXAgPSBbbGF0ICsgbGF0TGVuIC8gMiwgbGF0IC0gbGF0TGVuIC8gMl0ubWFwKGZ1bmN0aW9uIChsYXQpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgLSBsYXQgLyAxODA7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX21hcDIgPSBfc2xpY2VkVG9BcnJheShfbWFwLCAyKSxcbiAgICAgICAgICBfeSA9IF9tYXAyWzBdLFxuICAgICAgICAgIF95MiA9IF9tYXAyWzFdO1xuICAgICAgICBjb252ZXJ0TWVyY2F0b3JVVih0aWxlLmdlb21ldHJ5LmF0dHJpYnV0ZXMudXYsIF95LCBfeTIpO1xuICAgICAgfVxuICAgICAgZC5vYmogPSB0aWxlO1xuICAgIH1cbiAgICBpZiAoIWQubG9hZGluZykge1xuICAgICAgZC5sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gRmV0Y2ggdGlsZSBpbWFnZVxuICAgICAgbmV3IFRleHR1cmVMb2FkZXIoKS5sb2FkKF90aGlzNS50aWxlVXJsKHgsIHksIF90aGlzNS5sZXZlbCksIGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciB0aWxlID0gZC5vYmo7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgICAgdGlsZS5tYXRlcmlhbC5tYXAgPSB0ZXh0dXJlO1xuICAgICAgICAgIHRpbGUubWF0ZXJpYWwuY29sb3IgPSBudWxsO1xuICAgICAgICAgIHRpbGUubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIF90aGlzNS5hZGQodGlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZC5sb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBUaHJlZVNsaXBweU1hcEdsb2JlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs\n");

/***/ })

};
;